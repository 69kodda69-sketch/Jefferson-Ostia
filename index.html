<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Realistic Basketball Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to top, #3a5f0b, #87ceeb); /* grass to sky */
      font-family: Arial, sans-serif;
      text-align: center;
      user-select: none;
    }

    canvas {
      display: block;
      margin: 20px auto;
      background: #d18b47; /* wooden court */
      border-radius: 15px;
      box-shadow: 0 0 15px rgba(0,0,0,0.4);
    }

    #scoreBoard {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.9);
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 22px;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      user-select: none;
    }
  </style>
</head>
<body>

  <div id="scoreBoard">Score: <span id="score">0</span></div>
  <canvas id="gameCanvas" width="600" height="400"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");

    let score = 0;

    // Basketball ball object
    const ball = {
      x: 300,
      y: 350,
      radius: 15,
      color: "orange",
      dx: 0,
      dy: 0,
      isMoving: false,
      bounceFactor: 0.7,
      friction: 0.99,
      gravity: 0.4
    };

    // Hoop object with rim and net, centered horizontally
    const hoop = {
      x: canvas.width / 2 - 50,  // center horizontally (width 100)
      y: 100,
      width: 100,
      height: 12,
      rimRadius: 45,
    };

    // Draw hoop with rim and net
    function drawHoop() {
      // Backboard
      ctx.fillStyle = "#663300";
      ctx.fillRect(hoop.x + hoop.width + 10, hoop.y - 40, 15, 90);

      // Rim (orange)
      ctx.strokeStyle = "#FF4500";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(hoop.x + hoop.width / 2, hoop.y + hoop.height / 2, hoop.rimRadius, 0, Math.PI, true);
      ctx.stroke();

      // Net (white lines)
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      const rimX = hoop.x + hoop.width / 2;
      const rimY = hoop.y + hoop.height / 2 + hoop.rimRadius;

      for(let i = -hoop.rimRadius; i <= hoop.rimRadius; i += 10) {
        ctx.beginPath();
        ctx.moveTo(rimX + i, hoop.y + hoop.height / 2);
        ctx.lineTo(rimX + i / 2, rimY + 40);
        ctx.stroke();
      }
      for(let i = -hoop.rimRadius; i <= hoop.rimRadius; i += 10) {
        ctx.beginPath();
        ctx.moveTo(rimX + i, hoop.y + hoop.height / 2);
        ctx.lineTo(rimX + (i / 2) + 15, rimY + 40);
        ctx.stroke();
      }
    }

    // Draw ball with basketball lines
    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = ball.color;
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#b35400";
      ctx.stroke();

      // Basketball lines
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = "#b35400";

      // Vertical line
      ctx.beginPath();
      ctx.moveTo(ball.x, ball.y - ball.radius);
      ctx.lineTo(ball.x, ball.y + ball.radius);
      ctx.stroke();

      // Horizontal line
      ctx.beginPath();
      ctx.moveTo(ball.x - ball.radius, ball.y);
      ctx.lineTo(ball.x + ball.radius, ball.y);
      ctx.stroke();

      // Diagonal lines
      ctx.beginPath();
      ctx.moveTo(ball.x - ball.radius * 0.7, ball.y - ball.radius * 0.7);
      ctx.lineTo(ball.x + ball.radius * 0.7, ball.y + ball.radius * 0.7);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(ball.x + ball.radius * 0.7, ball.y - ball.radius * 0.7);
      ctx.lineTo(ball.x - ball.radius * 0.7, ball.y + ball.radius * 0.7);
      ctx.stroke();
    }

    // Update ball physics
    function updateBall() {
      if (ball.isMoving) {
        ball.x += ball.dx;
        ball.y += ball.dy;
        ball.dy += ball.gravity;

        // Bounce floor
        if (ball.y + ball.radius > canvas.height) {
          ball.y = canvas.height - ball.radius;
          ball.dy *= -ball.bounceFactor;
          ball.dx *= ball.friction;

          // Stop if bounce is very small
          if (Math.abs(ball.dy) < 1) {
            resetBall();
          }
        }

        // Bounce walls
        if (ball.x - ball.radius < 0) {
          ball.x = ball.radius;
          ball.dx *= -ball.bounceFactor;
        }
        if (ball.x + ball.radius > canvas.width) {
          ball.x = canvas.width - ball.radius;
          ball.dx *= -ball.bounceFactor;
        }

        // Check if ball passes through the rim (simple scoring)
        const rimCenterX = hoop.x + hoop.width / 2;
        const rimCenterY = hoop.y + hoop.height / 2;

        const distX = ball.x - rimCenterX;
        const distY = ball.y - rimCenterY;

        if (
          distY > 0 &&
          distY < ball.radius + 5 &&
          Math.abs(distX) < hoop.rimRadius - 5 &&
          ball.dy > 0
        ) {
          score++;
          scoreEl.textContent = score;
          resetBall();
        }

        // If ball goes off-screen below or sides, reset
        if (ball.y - ball.radius > canvas.height + 50) {
          resetBall();
        }
      }
    }

    // Reset ball to starting position
    function resetBall() {
      ball.x = 300;
      ball.y = 350;
      ball.dx = 0;
      ball.dy = 0;
      ball.isMoving = false;
    }

    // Draw wooden court floor texture (simple stripes)
    function drawCourtFloor() {
      const stripeHeight = 10;
      for (let y = 0; y < canvas.height; y += stripeHeight * 2) {
        ctx.fillStyle = y % (stripeHeight * 4) === 0 ? '#c58439' : '#d18b47';
        ctx.fillRect(0, y, canvas.width, stripeHeight);
      }
    }

    // Reusable shoot function (targetX, targetY, optional power)
    function shootBall(targetX, targetY, powerOverride) {
      if (!ball.isMoving) {
        const angle = Math.atan2(ball.y - targetY, targetX - ball.x);
        const dist = Math.min(Math.hypot(targetX - ball.x, targetY - ball.y), 150);
        const power = powerOverride !== undefined ? powerOverride : dist / 15;

        ball.dx = Math.cos(angle) * power;
        ball.dy = -Math.sin(angle) * power;
        ball.isMoving = true;
      }
    }

    // Handle click to shoot ball
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      shootBall(clickX, clickY);
    });

    // Keyboard listener for 'X' key to shoot towards hoop center with fixed power
    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === 'x') {
        // Shoot ball towards hoop center with fixed power 10
        shootBall(hoop.x + hoop.width / 2, hoop.y + hoop.height / 2, 10);
      }
    });

    resetBall();
    gameLoop();

    // Main game loop
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawCourtFloor();
      drawHoop();
      drawBall();
      updateBall();
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
